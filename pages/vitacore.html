<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VITACORE</title>
    
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body, html { 
            margin: 0; 
            padding: 0; 
            background: #000; 
            color: #111; 
            font-family: 'JetBrains Mono', monospace; 
            overflow: hidden; 
            width: 100vw; 
            height: 100vh;
        }
        
        .container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        /* --- BOTÓN VOLVER (NUEVO) --- */
        #btn-back {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #000;
            color: #ffffff; /* Texto blanco solicitado */
            border: 1px solid #333;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            padding: 8px 12px;
            text-transform: uppercase;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 100; /* Por encima de todo */
        }

        #btn-back:hover {
            background: #fff;
            color: #000;
            border-color: #fff;
        }

        /* --- PANEL IZQUIERDO --- */
        .panel-left {
            width: 350px;
            min-width: 350px;
            background: #080808;
            border-right: 1px solid #333;
            display: flex;
            flex-direction: column;
            padding: 40px;
            box-sizing: border-box;
            position: relative;
            z-index: 10;
            box-shadow: none; 
        }

        .header-title { color: #fff; font-weight: 800; font-size: 24px; margin-bottom: 5px; }
        .header-sub { color: #666; font-size: 11px; margin-bottom: 30px; }

        .monitor-box {
            width: 100%;
            height: 140px;
            background: #000;
            border: 1px solid #333;
            margin-bottom: 20px;
            position: relative;
        }
        
        .monitor-overlay {
            position: absolute;
            top: 5px; right: 5px;
            text-align: right;
            pointer-events: none;
        }
        .bpm-display { color: #22c55e; font-size: 20px; font-weight: bold; }
        .bpm-label { color: #444; font-size: 10px; }

        canvas { display: block; }

        /* SLIDERS */
        .controls-area { display: flex; flex-direction: column; gap: 25px; margin-bottom: 30px; }
        .slider-group { display: flex; flex-direction: column; gap: 8px; user-select: none; }
        .slider-label { display: flex; justify-content: space-between; color: #888; font-size: 10px; }
        
        .slider-track {
            width: 100%; height: 4px; background: #222; position: relative; cursor: pointer;
        }
        .slider-fill {
            height: 100%; background: #fff; pointer-events: none; width: 50%; transition: background 0.2s, width 0.5s cubic-bezier(0.22, 1, 0.36, 1);
        }
        .slider-thumb {
            width: 10px; height: 14px; background: #fff; position: absolute; top: -5px; 
            transform: translateX(-50%); pointer-events: none; border: 1px solid #000; left: 50%;
            transition: left 0.5s cubic-bezier(0.22, 1, 0.36, 1);
        }

        /* METER & BUTTONS */
        .chaos-meter { margin-top: auto; margin-bottom: 25px; }
        .meter-bar-bg { width: 100%; height: 6px; background: #111; margin-top: 5px; }
        .meter-bar-fill { height: 100%; width: 0%; transition: width 0.1s; background: #22c55e; }
        .status-text { font-size: 10px; margin-top: 5px; color: #666; }

        .btn-group { display: flex; gap: 10px; }
        button {
            flex: 1;
            background: #000;
            color: #fff;
            border: 1px solid #333;
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            padding: 12px 0;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
        }
        button:hover { background: #fff; color: #000; border-color: #fff; }
        #btn-download:hover { background: #ff4444; color: #fff; border-color: #ff4444; }

        /* --- PANEL DERECHO --- */
        .panel-right {
            flex: 1;
            background: #f4f4f4; 
            position: relative;
            overflow: hidden;
            display: flex;
        }
        
        #docCanvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

    <a href="blackmarket.html" id="btn-back">[ X ] EXIT_TO_MARKET</a>

    <div class="container">
        <div class="panel-left">
            <div class="header-title">VITACORE.SYS</div>
            <div class="header-sub">BIOMON_EDITOR</div>

            <div class="monitor-box">
                <canvas id="monitorCanvas" width="270" height="140"></canvas>
                <div class="monitor-overlay">
                    <div class="bpm-display" id="disp-bpm">--</div>
                    <div class="bpm-label">BPM</div>
                </div>
            </div>

            <div class="controls-area">
                <div class="slider-group" id="group-p1">
                    <div class="slider-label">
                        <span>HEART RATE (BPM)</span>
                        <span id="val-p1">--</span>
                    </div>
                    <div class="slider-track" id="track-p1">
                        <div class="slider-fill" id="fill-p1"></div>
                        <div class="slider-thumb" id="thumb-p1"></div>
                    </div>
                </div>
                <div class="slider-group" id="group-p2">
                    <div class="slider-label">
                        <span>VARIABILITY (HRV)</span>
                        <span id="val-p2">--</span>
                    </div>
                    <div class="slider-track" id="track-p2">
                        <div class="slider-fill" id="fill-p2"></div>
                        <div class="slider-thumb" id="thumb-p2"></div>
                    </div>
                </div>
                <div class="slider-group" id="group-p3">
                    <div class="slider-label">
                        <span>ST SEGMENT (OFFSET)</span>
                        <span id="val-p3">--</span>
                    </div>
                    <div class="slider-track" id="track-p3">
                        <div class="slider-fill" id="fill-p3"></div>
                        <div class="slider-thumb" id="thumb-p3"></div>
                    </div>
                </div>
            </div>

            <div class="chaos-meter">
                <div class="slider-label">
                    <span>PATIENT_STATUS</span>
                    <span id="meter-text" style="color: #22c55e;">LOADING...</span>
                </div>
                <div class="meter-bar-bg">
                    <div id="meter-fill" class="meter-bar-fill"></div>
                </div>
                <div class="status-text" id="status-sub">ANALYZING VITALS...</div>
            </div>

            <div class="btn-group">
                <button id="btn-reset">NORMALIZE</button>
                <button id="btn-download">EXPORT_ECG</button>
            </div>
        </div>

        <div class="panel-right" id="rightPanel">
            <canvas id="docCanvas"></canvas>
        </div>
    </div>

    <script>
        /* ================= CONFIGURACIÓN GLOBAL ================= */
        const UNIFORM_PADDING = 60; // Padding igual para todos los lados del canvas

        /* ================= ESTADO Y VARIABLES ================= */
        const state = {
            rawP1: 0, rawP2: 0, rawP3: 0, 
            bpm: 60, hrvMs: 0, stOffset: 0, riskLevel: 0,
            activeAlerts: [] 
        };

        let pulseBuffer = [];
        let time = 0;
        let animFrameId;
        
        let nextBeatTime = 0;
        let currentBeatDuration = 0;
        let beatPhase = 0; 

        let laneA_blocks = [];
        let laneB_squares = [];

        let previousRiskCount = 0;

        // DOM Elements
        const monitorCanvas = document.getElementById('monitorCanvas');
        const docCanvas = document.getElementById('docCanvas');
        const ctxM = monitorCanvas.getContext('2d');
        const ctxD = docCanvas.getContext('2d');
        const rightPanel = document.getElementById('rightPanel');

        const valP1 = document.getElementById('val-p1');
        const valP2 = document.getElementById('val-p2');
        const valP3 = document.getElementById('val-p3');
        const dispBpm = document.getElementById('disp-bpm');
        
        const meterFill = document.getElementById('meter-fill');
        const meterText = document.getElementById('meter-text');
        const statusSub = document.getElementById('status-sub');

        const WARNINGS_LIST = ["CARDIAC_ARREST", "V-FIB WARNING", "ISCHEMIA DETECTED", "CRITICAL FAILURE", "SYSTEM_OVERRIDE"];

        /* ================= INICIALIZACIÓN ================= */
        
        function resize() {
            const w = rightPanel.clientWidth || 1000;
            const h = rightPanel.clientHeight || 800;
            docCanvas.width = w;
            docCanvas.height = h;
            initLanes(w, h);
            if (state.riskLevel > 75) {
                generateAlertsData(w, h, previousRiskCount);
            }
        }

        window.addEventListener('resize', resize);
        
        window.onload = () => {
            const w = rightPanel.clientWidth || 1000;
            const h = rightPanel.clientHeight || 800;
            docCanvas.width = w;
            docCanvas.height = h;
            
            initLanes(w, h);
            randomizePatientState(); 
            calculateMedicalValues(); 
            loop();
        };

        function initLanes(W, H) {
            laneA_blocks = [];
            
            // Usamos el padding uniforme para calcular el ancho útil
            const usableW = W - (UNIFORM_PADDING * 2);

            // LANE A
            const blockW = 40; const blockH = 60; const gapA = 10;
            const totalBlocks = Math.floor(usableW / (blockW + gapA));
            
            for(let i=0; i<totalBlocks; i++) {
                let subs = [];
                for(let k=0; k<40; k++) subs.push({ r: Math.random() }); 
                laneA_blocks.push({ 
                    x: i*(blockW+gapA) + UNIFORM_PADDING, // Empieza después del padding izquierdo
                    w: blockW, 
                    h: blockH, 
                    subs 
                });
            }

            // LANE B
            laneB_squares = [];
            const sqSize = 10; const gapB = 5;
            const colsB = Math.floor(usableW / (sqSize+gapB));
            
            for(let i=0; i<colsB*4; i++) {
                laneB_squares.push({
                    x: (i%colsB)*(sqSize+gapB) + UNIFORM_PADDING, // Empieza después del padding izquierdo
                    yOff: Math.floor(i/colsB)*(sqSize+gapB),
                    noise: Math.random()
                });
            }
        }

        /* ================= GESTIÓN DE ESTADO ================= */

        function randomizePatientState() {
            const r1 = Math.floor(Math.random() * 100);
            const r2 = Math.floor(Math.random() * 100);
            const r3 = Math.floor(Math.random() * 100);
            updateSliderVisuals('p1', r1);
            updateSliderVisuals('p2', r2);
            updateSliderVisuals('p3', r3);
        }

        function normalizePatientState() {
            updateSliderVisuals('p1', 18);
            updateSliderVisuals('p2', 0);
            updateSliderVisuals('p3', 50);
        }

        function updateSliderVisuals(key, val0to100) {
            const fill = document.getElementById('fill-' + key);
            const thumb = document.getElementById('thumb-' + key);
            fill.style.width = val0to100 + '%';
            thumb.style.left = val0to100 + '%';
            if(key === 'p1') state.rawP1 = val0to100;
            if(key === 'p2') state.rawP2 = val0to100;
            if(key === 'p3') state.rawP3 = val0to100;
        }

        function generateAlertsData(w, h, count) {
            const newAlerts = [];
            const maxW = w - UNIFORM_PADDING - 250; 
            const minY = UNIFORM_PADDING;
            const maxY = h - UNIFORM_PADDING - 30; 

            for(let i=0; i<count; i++) {
                newAlerts.push({
                    x: UNIFORM_PADDING + Math.random() * (maxW - UNIFORM_PADDING),
                    y: minY + Math.random() * (maxY - minY),
                    txt: WARNINGS_LIST[Math.floor(Math.random() * WARNINGS_LIST.length)],
                    color: Math.random() > 0.5 ? '#ff0000' : '#000000',
                    hasBox: Math.random() > 0.8
                });
            }
            state.activeAlerts = newAlerts;
        }

        function calculateMedicalValues() {
            state.bpm = Math.floor(30 + (state.rawP1 * 1.7));
            state.hrvMs = state.rawP2; 
            state.stOffset = (state.rawP3 - 50) / 50; 

            valP1.innerText = state.bpm;
            valP2.innerText = state.hrvMs + "%";
            
            let stText = "NORMAL";
            if(state.stOffset < -0.2) stText = "DEPRESSION";
            if(state.stOffset > 0.2) stText = "ELEVATION";
            valP3.innerText = stText;
            dispBpm.innerText = state.bpm;

            let risk = 0;
            if(state.bpm < 50 || state.bpm > 120) risk += 30;
            if(state.bpm > 160) risk += 30;
            risk += state.hrvMs * 0.5;
            risk += Math.abs(state.stOffset) * 80;

            state.riskLevel = Math.min(100, risk);

            if (state.riskLevel > 75) {
                const currentCount = Math.floor((state.riskLevel - 75) / 3) + 2;
                if (currentCount !== previousRiskCount || state.activeAlerts.length === 0) {
                    generateAlertsData(docCanvas.width, docCanvas.height, currentCount);
                    previousRiskCount = currentCount;
                }
            } else {
                state.activeAlerts = [];
                previousRiskCount = 0;
            }
        }

        function getECGVoltage(phase, stShift) {
            let v = 0;
            if(phase > 0.1 && phase < 0.2) v += Math.sin((phase - 0.1) * Math.PI * 10) * 0.15;
            if(phase > 0.35 && phase < 0.38) v -= 0.15;
            if(phase > 0.38 && phase < 0.42) v += 1.2 * (1 - Math.abs(phase - 0.40)*50); 
            if(phase > 0.42 && phase < 0.45) v -= 0.25;
            if(phase > 0.45 && phase < 0.75) {
                let stMask = 0;
                if(phase > 0.45 && phase < 0.6) stMask = 1; 
                if(phase >= 0.6) stMask = 1 - (phase - 0.6)*5; 
                v += stShift * 0.4 * Math.max(0, stMask);
                if(phase > 0.55 && phase < 0.75) {
                    v += Math.sin((phase - 0.55) * Math.PI * 5) * 0.35;
                }
            }
            return v;
        }

        /* ================= LOOP ================= */

        function loop() {
            calculateMedicalValues();
            updateMeterUI();

            const now = Date.now();
            if (now > nextBeatTime) {
                let baseDur = 60000 / Math.max(1, state.bpm);
                let noise = (Math.random() - 0.5) * 2 * (state.hrvMs / 100) * baseDur;
                currentBeatDuration = baseDur + noise;
                nextBeatTime = now + currentBeatDuration;
            }

            let timeRemaining = nextBeatTime - now;
            beatPhase = 1 - (timeRemaining / currentBeatDuration);
            beatPhase = Math.max(0, Math.min(1, beatPhase));

            drawMonitor();
            drawTriLanes(); 

            animFrameId = requestAnimationFrame(loop);
        }

        /* ================= DIBUJADO ================= */

        function drawMonitor() {
            const W = monitorCanvas.width;
            const H = monitorCanvas.height;
            const voltage = getECGVoltage(beatPhase, state.stOffset);
            const yPos = (H/2) - (voltage * 40); 
            pulseBuffer.push(yPos);
            if(pulseBuffer.length > W) pulseBuffer.shift();

            ctxM.fillStyle = '#000'; ctxM.fillRect(0, 0, W, H);
            ctxM.strokeStyle = '#003300'; ctxM.lineWidth = 1;
            ctxM.beginPath();
            for(let x=0; x<W; x+=20) { ctxM.moveTo(x,0); ctxM.lineTo(x,H); }
            for(let y=0; y<H; y+=20) { ctxM.moveTo(0,y); ctxM.lineTo(W,y); }
            ctxM.stroke();

            let signalColor = '#22c55e'; 
            if(state.riskLevel > 40) signalColor = '#f59e0b'; 
            if(state.riskLevel > 75) signalColor = '#ef4444'; 

            ctxM.strokeStyle = signalColor;
            ctxM.lineWidth = 2;
            ctxM.lineJoin = 'round';
            ctxM.beginPath();
            for(let i=0; i<pulseBuffer.length; i++) {
                if(i===0) ctxM.moveTo(i, pulseBuffer[i]); else ctxM.lineTo(i, pulseBuffer[i]);
            }
            ctxM.stroke();
        }

        function drawTriLanes() {
            const W = docCanvas.width;
            const H = docCanvas.height;

            ctxD.fillStyle = '#f4f4f4'; ctxD.fillRect(0, 0, W, H);
            ctxD.fillStyle = '#111'; ctxD.strokeStyle = '#111';

            const baseA = H * 0.25;
            const baseB = H * 0.50;
            const baseC = H * 0.75;

            // LANE A (INVERTIDA)
            let visibility = (state.bpm - 30) / 170;
            visibility = Math.max(0.1, Math.min(1, visibility)); 

            laneA_blocks.forEach(block => {
                const subSize = 8; const subGap = 2;
                block.subs.forEach((s, idx) => {
                    if(s.r < visibility) {
                        const col = idx % 5;
                        const row = Math.floor(idx / 5);
                        ctxD.fillRect(block.x + col*(subSize+subGap), (baseA - block.h/2) + row*(subSize+subGap), subSize, subSize);
                    }
                });
            });

            // LANE B
            const extrudeFactor = state.rawP2 / 100; 
            laneB_squares.forEach(sq => {
                let h = 10;
                let y = baseB + sq.yOff;
                if(sq.noise > (1 - extrudeFactor*0.8)) {
                    const growth = sq.noise * 100 * extrudeFactor;
                    h += growth;
                    y -= growth;
                }
                ctxD.fillRect(sq.x, y, 10, h);
            });

            // LANE C
            const curveAmp = Math.abs(state.stOffset) * 100;
            const freq = 0.02;
            ctxD.lineWidth = 2;
            ctxD.beginPath();
            
            // Usamos el padding uniforme para el límite derecho de la curva
            const maxCurveX = W - UNIFORM_PADDING; 
            
            // Empezamos en el padding izquierdo
            for(let x=UNIFORM_PADDING; x < maxCurveX; x+=5) {
                let yOff = 0;
                if(state.stOffset !== 0) {
                    yOff = Math.sin(x * freq) * curveAmp * Math.sign(state.stOffset);
                    yOff += Math.sin(x * freq * 3) * (curveAmp * 0.2);
                }
                const y = baseC - yOff; 
                if(x===UNIFORM_PADDING) ctxD.moveTo(x, y); else ctxD.lineTo(x, y);
            }
            ctxD.stroke();

            drawLabels(W, H);
            
            if(state.riskLevel > 75 && state.activeAlerts.length > 0) {
                drawAlerts(W, H);
            }
        }

        function drawLabels(W, H) {
            ctxD.fillStyle = '#888';
            ctxD.font = '700 10px JetBrains Mono';
            // Usamos el padding uniforme para la posición X de las etiquetas
            ctxD.fillText(`FREQ_MOD [${state.bpm} BPM]`, UNIFORM_PADDING, H*0.25 - 50);
            ctxD.fillText(`NOISE_AMP [${state.hrvMs}%]`, UNIFORM_PADDING, H*0.50 - 50);
            const stLabel = state.stOffset > 0 ? "ELEVATION" : (state.stOffset < 0 ? "DEPRESSION" : "ISOELECTRIC");
            ctxD.fillText(`SEGMENT_ST [${stLabel}]`, UNIFORM_PADDING, H*0.75 - 50);
        }

        function drawAlerts(w, h) {
            ctxD.save();
            ctxD.beginPath();
            // El clip también respeta el padding para que no se corten las cajas en el borde
            ctxD.rect(UNIFORM_PADDING/2, UNIFORM_PADDING/2, w - UNIFORM_PADDING, h - UNIFORM_PADDING);
            ctxD.clip();

            ctxD.font = 'bold 20px JetBrains Mono';
            ctxD.shadowColor = '#fff';
            ctxD.shadowBlur = 0;

            state.activeAlerts.forEach(alert => {
                ctxD.fillStyle = alert.color;
                ctxD.fillText("⚠ " + alert.txt, alert.x, alert.y);
                
                if(alert.hasBox) {
                    ctxD.strokeStyle = '#ff0000';
                    ctxD.lineWidth = 2;
                    ctxD.strokeRect(alert.x - 10, alert.y - 25, 250, 40);
                }
            });

            ctxD.restore();
        }

        function updateMeterUI() {
            meterFill.style.width = `${state.riskLevel}%`;
            
            let color = '#22c55e';
            let txt = "NORMAL";
            let sub = "VITALS: STABLE";

            if(state.riskLevel > 40) { color = '#f59e0b'; txt = "WARNING"; sub = "VITALS: UNSTABLE"; }
            if(state.riskLevel > 75) { color = '#ef4444'; txt = "CRITICAL"; sub = "CODE BLUE DETECTED"; }

            meterFill.style.backgroundColor = color;
            meterText.style.color = color;
            meterText.innerText = txt;
            statusSub.style.color = state.riskLevel > 75 ? '#ef4444' : '#666';
            statusSub.innerText = sub;
        }

        /* ================= EVENTOS SLIDERS ================= */
        
        function setupSlider(trackId, fillId, thumbId, stateKey) {
            const track = document.getElementById(trackId);
            const update = (cX) => {
                const rect = track.getBoundingClientRect();
                let x = (cX - rect.left) / rect.width;
                x = Math.max(0, Math.min(1, x));
                let val100 = Math.round(x * 100);
                updateSliderVisuals(stateKey, val100);
            };
            track.addEventListener('mousedown', (e) => {
                update(e.clientX);
                const move = (ev) => update(ev.clientX);
                const up = () => { window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', up); };
                window.addEventListener('mousemove', move); window.addEventListener('mouseup', up);
            });
        }

        setupSlider('track-p1', 'fill-p1', 'thumb-p1', 'p1');
        setupSlider('track-p2', 'fill-p2', 'thumb-p2', 'p2');
        setupSlider('track-p3', 'fill-p3', 'thumb-p3', 'p3');

        /* ================= BOTONES ================= */
        document.getElementById('btn-reset').addEventListener('click', () => {
            normalizePatientState();
        });

        document.getElementById('btn-download').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `ECG_REPORT_${Date.now()}.png`;
            link.href = docCanvas.toDataURL('image/png');
            link.click();
        });

    </script>
</body>
</html>